---
description: 最低要件
globs:
alwaysApply: true
---

# 回答の原則
- 複雑な課題はサブタスクへ分解し、自然言語の中間推論（Chain-of-Thought）を生成してから結論を出す。
- 設定・前提・制約を明示。欠落情報は最小限の仮定を宣言して補う。
- 数値は単位付き。計算は手順を示し、可能なら簡易検算を行う。
- 反例・代替案・失敗条件を一度は点検する。
- 不確実性は「信頼度: 高/中/低」で表す。
- 冗長な前置きは不要。まず結論。続いて根拠。

## 手順
1) 要約: 課題を一文で再定義。  
2) 前提: 既知/未知/仮定を列挙。  
3) 分解: サブタスクと解法の見取り図。  
4) 推論: ステップごとに根拠→操作→結果。式やロジックは簡潔に。  
5) 検算: 桁・単位・境界条件・反例・整合性チェック。必要なら簡易計算で再確認。  
6) 決定: 要件を満たす最終結論と理由。  
7) 付記: 限界、追加調査ポイント、次の一手（必要時のみ）。

## コード/数式を扱う場合のみ
- 設計方針 → 擬似コード/式の導出 → 実装/計算 → 単体テスト/境界値 → 計算量や誤差。  
- 変更が必要な箇所はファイル/行の特定、差分提案、回帰影響の指摘を行う。  
- 入出力例を最小で提示。副作用とエラー条件を記述。

## 禁則
- 不明確な状態で断定しない。情報が不足する場合は明確化質問を最小数だけ提示するか、仮定を明示して進める。  
- 事実と推測を混同しない。出典が必要な主張は明示する。  
- 無関係な説明や感想は出力しない。

## その他の重視事項
- 修正が実施された場合、"README.md", "UserManual.md", ".gitignore", そして各テストコードも合わせてアップデートしてください。
- "README.md", "UserManual.md"には連絡事項は書かず、現状を淡々と反映させてください。
- git に危ういものがcommitされないように注意してください。
- frontend, backend の対応が正しいか常に注意してください。
- loggerのロギングを充実させてください。
- ダミー値で凌ぐのは許されません。ダミーを出力したくなるくらいならエラーを発生させてください。欠陥を隠ぺいするのは絶対にやめてください。
- エラーを解消すること自体が必ずしも目的ではありません。事象の根本的な課題をクリアすることが目的です。

---

# コーディング原則

## 1. DRY（Don't Repeat Yourself）
**目的**: 知識の重複を排除して変更点を一箇所に集約する。  
**必須ルール**
- 同一ロジック・定数・バリデーションが2回出たら抽出を検討。3回出たら抽出を義務化。
- 設定値は環境変数 or 設定モジュールに一元化。マジックナンバー禁止。
- 重複テストデータは factory/fixture に集約。
**アンチパターン**
- コピー＆ペースト修正。
- UI と API で同一の入力検証を別実装。
**リファクタ手順**: 探索 → 共通化単位決定（関数/クラス/モジュール）→ 抽出 → 逆依存解消 → テスト緑確認。

---

## 2. KISS（Keep It Simple, Stupid）
**目的**: 不必要な複雑性を避ける。  
**必須ルール**
- まず最小実装。分岐は3階層以内に抑える。巨大関数は 40–60 行を上限目安で分割。
- 早期 return でネスト削減。DSL やメタプログラミングは最後の手段。
- 依存ライブラリは最小限。標準機能で足りれば追加しない。
**アンチパターン**
- 未来の要件を想定した抽象化。
- 反射・動的 import の乱用。
**指標**
- 認知負荷: 初見5分で処理の骨子が追えること。

---

## 3. SoC（Separation of Concerns）
**目的**: 関心事を分離し結合度を下げる。  
**必須ルール**
- 層分割を守る: UI/Presentation ⇄ Application/Service ⇄ Domain ⇄ Infra/DB。
- クロスカット関心（ログ、計測、リトライ、認可）はミドルウェアやデコレータで注入。
- 例: フロントは状態管理と描画を分離（container/presentational）。
**アンチパターン**
- コンポーネント内で直接 fetch + DOM 操作 + 業務ロジック。
- ドメイン層から HTTP/ORM を直接呼ぶ。

---

## 4. SRP（Single Responsibility Principle）
**目的**: モジュールは一つの変更理由のみを持つ。  
**必須ルール**
- ファイル名と公開 API が責務を説明できること。曖昧なら分割。
- クラスは1ユースケース or 1ポリシー。ユーティリティ肥大化を禁止。
**アンチパターン**
- God Object / God Component。
- 1ファイルにモデル定義・入出力・整形・保存を混在。

---

## 5. YAGNI（You Aren’t Gonna Need It）
**目的**: 実際に必要になるまで実装しない。  
**必須ルール**
- Issue/要件にない抽象化・設定・拡張ポイントは追加しない。
- フラグだけの未使用コードを置かない。
**例外**
- セキュリティ・可観測性・エラーハンドリングの最低限は先行実装可。

---

## 6. POLA（Principle of Least Astonishment）
**目的**: 直感に反しない挙動と API。  
**必須ルール**
- 同種の関数は同じシグネチャと戻り値規約に統一。
- 非同期は常に `async`/`await` か Promise を返す。例外で同期値を返さない。
- 破壊的操作は明示名（`mutate*`、`delete*`）。暗黙副作用は禁止。
**UX準拠**
- バリデーションは入力直後に即時かつ一貫したメッセージ。

---

## 7. OCP（Open/Closed Principle）
**目的**: 変更に閉じて拡張に開く。  
**必須ルール**
- 条件分岐の追加ではなくポリモーフィズム・戦略パターンで差し替え可能に。
- 外部統合（支払、翻訳、ストレージ）はインターフェースで抽象化しアダプタ実装を分離。
**アンチパターン**
- `if type == 'A' ... elif type == 'B' ...` の列挙増殖。

---

## 8. エラーハンドリング / 可観測性
- 失敗は例外か `Result` 型で明示。黙殺しない。
- 期待可能な失敗（入力エラー、タイムアウト）は再試行・フォールバック方針を決める。
- ログは構造化（level, event, context）。PII はマスキング。
- 主要ユースケースにメトリクス埋め込み（成功率、p95 latency、再試行率）。

---

## 9. テスト規約（DRY/SoC を満たす）
- ピラミッド: Unit を厚く、Integration を必要十分、E2E はクリティカル経路のみ。
- Given/When/Then で可読化。重複データは factory/fixture に集約。
- UI テストはロール/ラベルで選択（`getByRole` 等）。`data-testid` は最終手段。
- ネットワーク越しは基本モック。契約テストで境界を保証。
- カバレッジ目安: line 80% / branch 70%。数字至上主義にしない。

---

## 10. 依存と構成管理
- 依存は最小。未使用依存は削除。ロックファイルを更新し CVE を監視。
- 設定は12-factor準拠。秘密情報は環境変数や秘密管理に置く。
- 公開 API の破壊的変更はセマンティックバージョニングに従う。

---

## 11. スタイルと可読性
- 命名は用途を一意に示す。略語は一般的なもののみ。
- 関数は副作用の有無を名前で示す（`calculate*` vs `update*`）。
- コメントは「なぜ」を書く。「何を」はコードで表す。

---