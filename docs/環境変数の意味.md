### 設定の読み込み規則（重要）
- **読み込み元**: `.env` が読み込まれます（サンプルは `env.example`）。未使用キーは無視されます。大文字/小文字は区別しません。  
```104:112:apps/backend/backend/config.py
    model_config = SettingsConfigDict(
        env_file=".env",
        extra="ignore",
        case_sensitive=False,
    )
```
- **フィールド名と環境変数名の対応**: `llm_provider` ⇔ `LLM_PROVIDER` のように、スネークケース⇔大文字アンダースコアで自動対応します。
- 以降の既定値は「1) env.example のサンプル値」「2) コード側のデフォルト値」の両方を明記します（実際は `.env` による上書きが有効）。

---

### 1) ENVIRONMENT
- 用途: 実行環境の識別（ロギング方針や運用切替のフラグに利用可能）。現時点では主にメタ情報。
- 既定値: env.example=development / コード既定="development"
- 使われ方: `apps/backend/backend/config.py` のみで保持（直接の分岐は現状なし）。
- 未設定/誤設定: 未設定なら "development"。誤設定でも致命的影響なし。
- 設定例: 本番で `"production"`。

---

### 1.5) GOOGLE_CLIENT_ID / GOOGLE_ALLOWED_HD
- 用途: Google サインインの ID トークン検証とドメイン制限。
- 既定値: env.example=`GOOGLE_CLIENT_ID=`（空文字）, `# GOOGLE_ALLOWED_HD=`（未設定）。コード既定は `google_client_id=""`, `google_allowed_hd=None`。
- 使われ方: Google から受け取った ID トークンを検証し、必要に応じて許可ドメインを照合します。
```37:92:apps/backend/backend/routers/auth.py
    if not settings.google_client_id:
        ...
    id_info = id_token.verify_oauth2_token(..., settings.google_client_id)
    allowed_hd = (settings.google_allowed_hd or "").strip()
    if allowed_hd and hosted_domain != allowed_hd:
        raise HTTPException(status_code=HTTPStatus.FORBIDDEN, detail="Google account domain is not allowed")
```
- 未設定/誤設定:
  - `GOOGLE_CLIENT_ID` が空のまま起動すると `/api/auth/google` が 500 を返却し、認証できません。
  - `GOOGLE_ALLOWED_HD` を設定した場合は完全一致で照合されるため、Google Workspace ドメインと一致させる必要があります。
- 設定例:
  - 一般的な OAuth クライアント: `GOOGLE_CLIENT_ID=12345-abcdefgh.apps.googleusercontent.com`
  - ドメイン制限を掛ける場合: `GOOGLE_ALLOWED_HD=example.com`
  - フロントエンドで同じ ID を共有: `apps/frontend/.env` に `VITE_GOOGLE_CLIENT_ID=12345-abcdefgh.apps.googleusercontent.com`
- 運用メモ:
  - Google Cloud Console で OAuth クライアント ID を作成すると JSON シークレットがダウンロードできます。`google-oauth-client-secret.json` などの名前で安全な場所に保管し、リポジトリには追加しないでください。
  - `.env` を編集したらバックエンドプロセスを再起動し、`apps/frontend/.env` を更新したら `npm run dev` を再実行して読み込み直してください。

#### 1.5.1) GOOGLE_CLOCK_SKEW_SECONDS
- 用途: Google の ID トークン検証時に `iat`/`nbf`/`exp` の境界に対して許容する時計ずれ（秒）を指定。  
  Docker/WSL などで VM の時計がホストと僅かにずれる環境でも “Token used too early” を回避できます。
- 既定値: env.example=`# GOOGLE_CLOCK_SKEW_SECONDS=60`（コメントアウト） / コード既定=`google_clock_skew_seconds=60`
- 使われ方:
```59:69:apps/backend/backend/routers/auth.py
    _skew = max(0, int(getattr(settings, "google_clock_skew_seconds", 0) or 0))
    try:
        id_info = id_token.verify_oauth2_token(..., clock_skew_in_seconds=_skew)
    except TypeError:
        id_info = id_token.verify_oauth2_token(... )  # 旧バージョン互換
```
- 注意点: 値を大きくし過ぎると時刻検証の厳密さが下がります。通常は 30–60 秒で十分です。

#### 1.5.2) ADMIN_EMAIL_ALLOWLIST
- 用途: Google 認証後にメールアドレス単位の許可リストを適用し、指定アカウント以外のログインを拒否します。
- 既定値: env.example=`# ADMIN_EMAIL_ALLOWLIST=admin@example.com,owner@example.com`（コメントアウト） / コード既定=`admin_email_allowlist=()`（空タプル）。
- 使われ方:
```72:115:apps/backend/backend/routers/auth.py
    allowlisted_emails = getattr(settings, "admin_email_allowlist", ())
    if allowlisted_emails:
        normalised_email = email.strip().lower()
        if normalised_email not in allowlisted_emails:
            raise HTTPException(status_code=HTTPStatus.FORBIDDEN, detail="Google account email is not allowlisted")
```
- 未設定/誤設定:
  - 空文字やコメントアウトのままの場合は許可リストが無効となり、従来どおりメールアドレス制限は掛かりません。
  - ただし `ENVIRONMENT=production` で空のままデプロイすると、設定バリデーションが `ValueError` を送出して Cloud Run などでの起動が停止します。事前に `.env.deploy` へ許可する管理者メールアドレスを列挙してください。
  - 値はカンマ区切りで指定し、余分な空白は自動的に除去されます。小文字へ正規化されるため、大文字小文字を意識する必要はありません。
  - 重複するメールアドレスは除外され、`google_auth_denied` ログには `allowlist_size` とハッシュ化されたメールアドレスが記録されます。
  - 認証成功時の `google_auth_succeeded` も `email_hash` / `display_name_hash` として Cloud Logging に送信されるため、平文の識別子は残りません。
- 設定例:
  - 管理者のみ許可: `ADMIN_EMAIL_ALLOWLIST=admin@example.com`
  - 複数名を許可: `ADMIN_EMAIL_ALLOWLIST=admin@example.com,owner@example.com`

---

### 1.6) SESSION_SECRET_KEY / SESSION_COOKIE_NAME / SESSION_COOKIE_SECURE / SESSION_MAX_AGE_SECONDS
- 用途: 署名付きセッショントークンの生成と検証、Cookie 名称・寿命の制御。
- 既定値: env.example=`SESSION_SECRET_KEY=`（空なので利用者が乱数値を必ず入力する）、`SESSION_COOKIE_NAME=wp_session`, `# SESSION_COOKIE_SECURE=true`, `# SESSION_MAX_AGE_SECONDS=1209600`。コード既定は `session_secret_key=""`, `session_cookie_name="wp_session"`, `session_cookie_secure=(environment == "production")`, `session_max_age_seconds=1209600`。
- 使われ方: セッションシリアライザの初期化と HTTP 応答での Set-Cookie 設定に利用されます。Firebase Hosting が `__session` 以外の Cookie を Cloud Run へ転送しない制約に備え、FastAPI 側では `SESSION_COOKIE_NAME` によらず `__session` も常に同一トークンで配信します。
```21:44:apps/backend/backend/auth.py
def _build_serializer() -> URLSafeTimedSerializer:
    secret = settings.session_secret_key.strip()
    if not secret:
        raise RuntimeError("SESSION_SECRET_KEY is not configured")
    return URLSafeTimedSerializer(secret, salt=_SESSION_SALT)
```
```157:168:apps/backend/backend/routers/auth.py
for cookie_name in session_cookie_names():
    response.set_cookie(
        key=cookie_name,
        value=session_token,
        httponly=True,
        secure=settings.session_cookie_secure,
        samesite="lax",
        max_age=_session_cookie_max_age(),
    )
```
- 未設定/誤設定:
  - `SESSION_SECRET_KEY` が空、`change-me` などの既知プレースホルダー、32 文字未満の短い値、あるいは過去に公開したサンプル値（ハッシュ照合）に該当すると初期化時に例外が発生し、アプリケーションは起動しません。実運用では `openssl rand -base64 48 | tr -d '\n'` などで生成した乱数文字列を設定してください。
  - `SESSION_COOKIE_SECURE` は ENVIRONMENT が `production` のときのみ既定で True。`development`/`staging` などでは False なので HTTP での Cookie 配信が可能です。本番で HTTPS を使う場合は `.env` または環境変数で `true` を明示してください。
  - `SESSION_MAX_AGE_SECONDS` は整数で指定。負数や文字列の場合は既定の 14 日間にフォールバックします。
- 設定例:
  - `SESSION_SECRET_KEY=$(openssl rand -base64 48 | tr -d '\n')`
  - `SESSION_COOKIE_NAME=wp_session`
  - 本番 HTTPS 運用: `SESSION_COOKIE_SECURE=true`
  - 有効期限を 7 日に短縮: `SESSION_MAX_AGE_SECONDS=604800`

---

### 1.7) CORS_ALLOWED_ORIGINS
- 用途: FastAPI の `CORSMiddleware` で資格情報付きリクエストを許可するオリジンを列挙する。
- 既定値: env.example=`# CORS_ALLOWED_ORIGINS=`（未設定） / コード既定=`allowed_cors_origins=()`（空タプル）。
- 使われ方:
```109:126:apps/backend/backend/main.py
    configured_origins = list(settings.allowed_cors_origins)
    allow_credentials = bool(configured_origins)
    if not configured_origins:
        configured_origins = ["*"]
    app.add_middleware(
        CORSMiddleware,
        allow_origins=configured_origins,
        allow_credentials=allow_credentials,
        allow_methods=["*"],
        allow_headers=["*"],
    )
```
- 未設定/誤設定:
  - 未設定のまま起動すると `allow_origins` がワイルドカード `*` になり、`Access-Control-Allow-Credentials` は返りません（クッキー連携不可）。
  - HTTPS や複数ドメイン構成では本番のオリジン（例: `https://app.example.com`）を正確に列挙してください。末尾のスラッシュやポート番号も一致している必要があります。
- 設定例:
  - ローカル: `CORS_ALLOWED_ORIGINS=http://127.0.0.1:5173,http://localhost:5173`
  - 本番: `CORS_ALLOWED_ORIGINS=https://app.example.com,https://admin.example.com`

---

### 1.8) TRUSTED_PROXY_IPS
- 用途: `ProxyHeadersMiddleware` に渡す信頼済みプロキシ（IP または CIDR）の一覧。`X-Forwarded-For` / `X-Forwarded-Proto` を信頼できる送信元に限定する。
- 既定値: env.example=`# TRUSTED_PROXY_IPS=`（未設定） / コード既定=`trusted_proxy_ips=("127.0.0.1",)`。
- 使われ方:
```115:136:apps/backend/backend/main.py
    configured_proxies = [value for value in settings.trusted_proxy_ips if value]
    if not configured_proxies:
        configured_proxies = ["127.0.0.1"]
    proxy_argument: list[str] | str
    if len(configured_proxies) == 1:
        proxy_argument = configured_proxies[0]
    else:
        proxy_argument = list(configured_proxies)
    app.add_middleware(
        ProxyHeadersMiddleware,
        **{_PROXY_MIDDLEWARE_PARAM: proxy_argument},
    )
```
- 未設定/誤設定:
  - 空文字やスペースだけを指定すると `127.0.0.1` のみが信頼対象となり、Cloud Run 経由のリクエストでは `request.client.host` がプロキシ IP のままになります。
  - 実際に経由するプロキシのレンジを列挙しないと、`X-Forwarded-For` の情報が破棄されるため RateLimitMiddleware が常に同じ IP とみなす（= 全員が即座に 429 になる）恐れがあります。
- 設定例:
  - Cloud Run + Cloud Load Balancing: `TRUSTED_PROXY_IPS=35.191.0.0/16,130.211.0.0/22`
  - オンプレで複数段プロキシ: `TRUSTED_PROXY_IPS=10.0.0.0/24,192.168.0.0/24`

---

### 1.9) ALLOWED_HOSTS
- 用途: Starlette `TrustedHostMiddleware` で許可する Host ヘッダを列挙し、ホスト名偽装を防ぐ。
- 既定値: env.example=`# ALLOWED_HOSTS=`（未設定） / コード既定=`allowed_hosts=("*",)`。
- 使われ方:
```122:126:apps/backend/backend/main.py
    configured_hosts = list(settings.allowed_hosts)
    if not configured_hosts:
        configured_hosts = ["*"]
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=configured_hosts,
    )
```
- 未設定/誤設定:
  - 空のまま起動すると `*` が適用されるため、本番環境では設定ガードが起動を拒否します。外部公開環境では必ず Cloud Run 既定 URL やカスタムドメインを明示してください。
  - `*` を含む設定（例: `ALLOWED_HOSTS=*,api.example.com`）もワイルドカード扱いとして拒否されます。
  - 存在しないホスト名を指定すると 400 (`Invalid host header`) が返り、フロントエンドからアクセスできなくなります。
- 設定例:
  - Cloud Run 既定ホスト + カスタムドメイン: `ALLOWED_HOSTS=app-1234567890-uc.a.run.app,api.example.com`
  - ローカル開発: `ALLOWED_HOSTS=testserver,localhost,127.0.0.1`

---

### 2) LLM_PROVIDER, LLM_MODEL, LLM_TIMEOUT_MS, LLM_MAX_RETRIES, LLM_MAX_TOKENS
- 用途:
  - `LLM_PROVIDER`: LLM クライアントの選択。`openai` | `local`
- `LLM_MODEL`: 使うモデル名（例: `gpt-4o-mini` / `gpt-4.1-mini` / `gpt-5-mini` / `gpt-5-nano`）
  - `LLM_TIMEOUT_MS`: 1回の LLM 呼び出しのタイムアウト
  - `LLM_MAX_RETRIES`: LLM 呼び出しの最大リトライ回数
- 既定値:
  - env.example: `LLM_PROVIDER=openai`, `LLM_MODEL=gpt-4o-mini`, `LLM_TIMEOUT_MS=45000`, `LLM_MAX_RETRIES=1`, `LLM_MAX_TOKENS=1500`
  - コード既定: `llm_provider="openai"`, `llm_model="gpt-4o-mini"`, `llm_timeout_ms=60000`, `llm_max_retries=1`, `llm_max_tokens=900`
- 使われ方:
  - プロバイダ選択と初期化
```128:146:apps/backend/backend/providers.py
    provider = (settings.llm_provider or "").lower()
    try:
        if provider == "openai" and settings.openai_api_key:
            _LLM_INSTANCE = _llm_with_policy(_OpenAILLM(api_key=settings.openai_api_key, model=settings.llm_model))
            return _LLM_INSTANCE
        # 未対応プロバイダはローカルフォールバック
        _LLM_INSTANCE = _llm_with_policy(_LocalEchoLLM())
        return _LLM_INSTANCE
```
  - タイムアウト/リトライの適用（試行ごとにタイムアウト、指数的ではない短いバックオフ）
```99:111:apps/backend/backend/providers.py
        def complete(self, prompt: str) -> str:
            last_exc: Exception | None = None
            for attempt in range(1, max(1, settings.llm_max_retries) + 1):
                try:
                    future = _llm_executor.submit(llm.complete, prompt)
                    return future.result(timeout=settings.llm_timeout_ms / 1000.0)
                except Exception as exc:
                    last_exc = exc
                    if attempt >= max(1, settings.llm_max_retries):
                        break
                    time.sleep(0.1 * attempt)
            return ""
```
- 未設定/誤設定:
  - `LLM_PROVIDER=openai` でも `OPENAI_API_KEY` が空なら、自動で安全なローカルフォールバック（空文字を返す）に切替。
  - 失敗時は例外を投げず空文字を返す設計（上位はフォールバック前提）。
  - `LLM_MAX_TOKENS` は Responses API の `max_output_tokens`（または互換名）として使用され、JSON途中切れの防止に寄与。
- 設定例:
  - OpenAI: `LLM_PROVIDER=openai`, `LLM_MODEL=gpt-4o-mini|gpt-4.1-mini|gpt-5-mini|gpt-5-nano` など + `OPENAI_API_KEY`
  - オフライン学習/テスト: `LLM_PROVIDER=local`
  - 推論系（gpt-5-mini）を使う場合は UI から `reasoning.effort`/`text.verbosity` を指定（サーバ側は SDK 未対応項目を自動除去）

---

### 3) EMBEDDING_PROVIDER, EMBEDDING_MODEL
- 用途: ベクトル検索用の埋め込み生成のプロバイダとモデル指定。
- 既定値: env.example=`openai`/`text-embedding-3-small`、コード既定も同じ。
- 使われ方:
```162:179:apps/backend/backend/providers.py
    provider = (settings.embedding_provider or "").lower()
    if provider == "openai" and settings.openai_api_key and OpenAI is not None:
        client = OpenAI(api_key=settings.openai_api_key)
        model = settings.embedding_model
        class _OpenAIEmbedding:
            def __call__(self, texts: List[str]) -> List[List[float]]:
                ...
                resp = client.embeddings.create(model=model, input=chunk)
                ...
        return _OpenAIEmbedding()
    return SimpleEmbeddingFunction()
```
- 未設定/誤設定: OpenAI キーが無い/SDK未導入なら、決定的なダミー埋め込み（次元8）に自動フォールバック。
- 設定例: OpenAI を使う場合 `EMBEDDING_PROVIDER=openai`, `EMBEDDING_MODEL=text-embedding-3-small` か `text-embedding-3-large` など。

---

### 4) OPENAI_API_KEY
- 用途: OpenAI（LLM/Embeddings）の認証。
- 既定値: 空（必須の場合はユーザーが設定）
- 使われ方: 上記 LLM/埋め込みの分岐で参照。
- 未設定/誤設定: 自動フォールバック（LLM は local、Embeddings はダミー）。

---

 

---

### 6) （削除済み）ベクトル検索関連の環境変数
本プロジェクトではベクトル検索の環境変数は廃止されました。

---

### 7) CHROMA_PERSIST_DIR / CHROMA_SERVER_URL
- 用途:
  - `CHROMA_PERSIST_DIR`: ローカル永続ディレクトリ（サーバURL未指定時に使用）
  - `CHROMA_SERVER_URL`: リモートの Chroma サーバーを使う場合の接続先
- 既定値: env.example は `.chroma`、URL はコメントアウト（未指定）
- 使われ方:
```190:206:apps/backend/backend/providers.py
    def __init__(self, persist_directory: Optional[str] = None) -> None:
        self.persist_directory = persist_directory or settings.chroma_persist_dir
    def create_client(self) -> Any | None:
        ...
        if getattr(settings, "chroma_server_url", None):
            ...
            underlying = http_cls(host=settings.chroma_server_url)
        else:
            underlying = chromadb.PersistentClient(path=self.persist_directory)
```
- 未設定/誤設定:
  - SDK未導入/接続失敗時は軽量なインメモリ互換クライアントに自動フォールバックし、動作継続。
- 設定例:
  - ローカル永続: `CHROMA_SERVER_URL` 未設定、`CHROMA_PERSIST_DIR=.chroma`
  - リモート接続: `CHROMA_SERVER_URL=https://chroma.example`（この場合 persist は使わない）

---

### 8) FIRESTORE_PROJECT_ID / FIRESTORE_EMULATOR_HOST
- 用途:
  - `FIRESTORE_PROJECT_ID`: Firestore へ接続するプロジェクト ID（Cloud/エミュレータ共通）
  - `FIRESTORE_EMULATOR_HOST`: ローカルエミュレータのホスト名:ポート
- 既定値: env.example は `wordpack-local` / `127.0.0.1:8080`（コメント付き）、コード側では開発環境で未指定の場合 `wordpack-local` を自動採用
- 使われ方:
```apps/backend/backend/store/__init__.py
def _build_firestore_client() -> firestore.Client:
    emulator_host = _normalize_emulator_host(settings.firestore_emulator_host or os.environ.get("FIRESTORE_EMULATOR_HOST"))
    project_id = settings.firestore_project_id or settings.gcp_project_id
    ...
    return firestore.Client(project=project_id, client_options={"api_endpoint": emulator_host})
```
  - エミュレータ指定時は匿名認証で接続し、未指定時は Cloud Firestore 用のクライアントを生成します。
- 未設定/誤設定:
  - 本番（ENVIRONMENT=production）かつプロジェクト ID 未指定の場合、設定バリデーションで失敗します。
  - エミュレータホストが不正（スキームやポートが欠落）な場合、接続時にエラーとなります。
- 設定例:
  - エミュレータ: `FIRESTORE_PROJECT_ID=wordpack-local`、`FIRESTORE_EMULATOR_HOST=127.0.0.1:8080`
  - 本番 Firestore: `FIRESTORE_PROJECT_ID=my-gcp-project`（`FIRESTORE_EMULATOR_HOST` は未設定）、`GOOGLE_APPLICATION_CREDENTIALS` でサービスアカウント JSON を指定

---

### 9) RATE_LIMIT_PER_MIN_IP / RATE_LIMIT_PER_MIN_USER
- 用途: API 全体のレート制限（トークンバケット、毎分補充）。IP 単位/認証セッション単位（署名付き Cookie）。
- 既定値: env.example=240/240、コード既定も同じ
- 使われ方（ミドルウェアに注入）:
```42:47:apps/backend/backend/main.py
app.add_middleware(
    RateLimitMiddleware,
    ip_capacity_per_minute=settings.rate_limit_per_min_ip,
    user_capacity_per_minute=settings.rate_limit_per_min_user,
)
```
- 429 時のレスポンスヘッダ（残量など）:
```118:126:apps/backend/backend/middleware.py
response.headers.setdefault("X-RateLimit-Limit-Ip", str(self._ip_capacity))
response.headers.setdefault("X-RateLimit-Remaining-Ip", str(remaining_ip))
...
```
- 未設定/誤設定:
  - 値は1以上にクランプ。誤って 0 等を設定しても最低 1 になります。
  - セッション Cookie が無い/失効時は共通キー（anon）に集約されるため、ヘッダ偽装では回避できません。
- 設定例: 公開環境で `RATE_LIMIT_PER_MIN_IP=120`, `RATE_LIMIT_PER_MIN_USER=240` など。

---

### 10) SENTRY_DSN
- 用途: Sentry にログ/例外を送信（任意）。
- 既定値: 空（無効）
- 使われ方:
```27:36:apps/backend/backend/logging.py
if settings.sentry_dsn:
    import sentry_sdk
    from sentry_sdk.integrations.logging import LoggingIntegration
    sentry_logging = LoggingIntegration(level=logging.INFO, event_level=logging.ERROR)
    sentry_sdk.init(dsn=settings.sentry_dsn, integrations=[sentry_logging])
```
- 未設定/誤設定: 未設定なら無効、初期化失敗でもアプリは継続。
- 設定例: `SENTRY_DSN=https://<public_key>@<host>/<project>`

---

### よくある組み合わせ（実運用のヒント）
- 開発（オフライン想定）:
  - `LLM_PROVIDER=local`, `EMBEDDING_PROVIDER=openai`（キー無しでもダミー動作）
- ステージング/本番（OpenAI）:
  - `LLM_PROVIDER=openai`, `LLM_MODEL=gpt-4o-mini`, `OPENAI_API_KEY=...`
  - `EMBEDDING_PROVIDER=openai`, `EMBEDDING_MODEL=text-embedding-3-small`
- 負荷制御:
（該当なし）
- 監視:
  - 必要に応じて `SENTRY_DSN` を有効化

---

- 以上、`env.example` の各変数が「どこでどう使われ、未設定時にどう振る舞うか」まで落とし込んで説明しました。さらに掘り下げたい項目（例: Azure の具体的デプロイ手順、Chroma のサーバーモード運用など）があれば言ってください。

- 主要箇所の要点
  - `.env` を読み、未使用キーは無視・大文字小文字は不問。
  - LLM と Embeddings はキー未設定でも安全にフォールバック。
（該当なし）
  - API 全体のレート制限は IP と User の二系統。
- Firestore は WordPack/記事保存専用の永続層で、ローカル開発時はエミュレータ接続を推奨します。
